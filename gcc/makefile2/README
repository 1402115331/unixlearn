1.make的工作模式分为两种情景：
   （1）如同一个连锁反应式的工作，就是目标、依赖、命令全部都存在的方式，这里有一个自动触发过程。
	make命令执行的时候会比较依赖和target的创建时间来查看文件内容是否有变化。所以在这一部分，如果希望把头文件的更新影响也添加到这个判断机制中就必须把头文件也声明在这里。事实上如果不把头文件放在这里编译的时候也不会有影响，只是头文件的更新就不会触发这个检查过程啦而已,所以对于编译好内容make后，然后删除头文件，再次make的时候并不会产生任何不良影响
	make在检查依赖和target的创建时间的时候，如果发现.o文件不存在就会自动触发，自己的列表中的target为这个.o的文件生成.o文件。这是通过这一层层的递归，完成了所有文件的生成。
	我们之所以直接make后面不需要任何target都能生成需要的执行文件，关机就在于make直接就触发了这个连锁反应
    （2）第二种模式就是target后面没有依赖的情况，那么对于这种情况这就不存在检查时间生成文件的问题啦，这个时候make就相当于自定义了一个命令别名
2.对于command的内容就是直接的交给shell去执行的命令啦，和直接写的command没有差别。
***********************************
make执行的时候并不判断command是否执行成功，只有当依赖检查命令是否执行成功，只检查依赖关系，只有你声明的依赖关系被找不到那么make就会停止，置于这种依赖是否正确，是否完整不是make关系的这是command的权利范围。
------------------------------------


功能本身都是很简单的，但是为了维护的方便使用的变量才是最容易让人模糊的，make也支持变量

















