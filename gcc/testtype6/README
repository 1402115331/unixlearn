宏必须定义在gcc里或者定义在头文件里
可以用cpp -dM /dev/null 查看当前系统定义的所有宏变量

---------------------------------------------------
  gcc -save-temps  macros.c 
  gcc -E  macros.c 
gcc设置宏的时候会有个预编译，这是对我们开发调试最方便的，如果想看有效的宏内容effect 就用-E标记，就可以了
也可以使用-save-temps他的作用和文件名一样的间接就是保存临时文件的 包括.i .o 等文件
----------------------------------------------------
gcc能从众多的字节码方案中选择一种最适合当前主机的方式使用：
1.优化表达式
2.使用内联函数-->函数跳转需要保存原函数地址压栈，需要跳转，需要设置ip，这些操作都是很多步骤，需要一定时间的；内连就保证在函数内跳转至少节省了跳转点地址压栈的操作，虽然只是省了很少的几部，但是对于编译器来说，代码的质量也已经差别很明显啦
内敛函数使用情景和好处：
1.方法被请求的次数很少，因为写代码的时候本就是可以直接写到调用位置的，但是为了保持结构的整洁而使用了方法，那么使用inline即能达到只写写到调用者位置的效果，有能是结构保持更简单
2.使用内敛减少函数跳转的次数，也就是减少cpu调用时候的动作数
3.能减少内存的使用

-----------------------------------------------------
gcc的优化方法还包括：
1.把循环展开，节省判断的次数，（但是增大了代码空间，所以这种东西也只能编译器去优化，如果手动写那些代码，估计早崩溃啦）
2.在系统中cpu并不是全能的，即使是上帝也有很多事情，不在他的视线范围里，gcc优化代码考虑到了cpu的流水线操作，所以会把代码分拆的更加适合流水线的执行。。
3.

------------------------------------------------------
gcc为优化设置了4个级别
-0 级别0，是源码到二进制文件意义对应的翻译，不做任何源文件的 cpu的优化，是最适合debug的级别
-1 级别1，只是做了轻量级的优化，像cpu级别的优化并没有进行，不没有进行速度和时间的大量权衡
-2 级别2，更重量级的优化，考虑了cpu的流水线操作，编译的文件相对-1要大的多，比较适合打包操作，是gnu默认的打包操作
-3 级别3，最重量级的优化，涵盖了上述全部的优化，并且还加入了内链优化，文件是这四个级别中最大的，理论上也是最快的，但不保证，不是特别常用
默认调试模式使用-0 运行模式使用-2

另外除了这些打包好的优化方案意外，gcc也提供了单独的优化选项，使用者可以根据自己的需求单独决定开启某项优化，更加拓展了编译优化的灵活性。
-funroll-loops 开启循环的时候代码展开，减少判断次数，但是会加大文件的大小。
-Os 编译最小的文件，但是不一定速度就慢

--------------------------------------------------------
可以看出，
一般情况下编译出来的文件肯定比源文件大，并且在一定程度上是越大速度越快（当然肯定有个奇点），所谓的优化本身就是类似于抽象的操作，抽象是把众多同类的实物中提出出来共同的部分，单独处理。这里其实也是。一份源文件的功能需要在众多的种类繁多的机器上运行，这些众多的种类繁多的运行中的主题就构成了抽象的作用对象就是抽象的主题，gcc进行的各种代码优化等的操作就是抽象的过程，得到的二进制文件就是抽象的结构。好处就是部署的机器不必在执行例如对展开字节码的if判断等，直接使用就可以啦。优化本质上就是处理这两者之间的关系。

