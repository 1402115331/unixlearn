我们之前说头文件只是对照用的，真是的方法在二进制的.o中，实际上在我们使用#include<stdlib.h>的时候，还有一个作用就是把声明这个头文件的动态库纳入方法的搜索范围，当然这只是gcc为我们做的方便之举而已，并不是头文件的本质作用。。。默认的用法应该是 gcc -Wall calc.c /usr/lib/libm.a -o cal.c
如上：也就是说我们给gcc输入的不必全是.o或者全是.c的文件，我们也可以输入的数据里既有.o也有.c 这个特征在编译应用动态库的源代码时候使用的最频繁。。。
因为系统提供的头文件和系统提供的实现文件又明确确定的一对一关系，所以gcc里就维护了这样一个列表使我们可以直接根据系统库的头文件找到对应的二进制文件，而不需要再人工指定啦，我们可以直接用-l 即link 简化这个操作(这里的m是more的意思)，上述命令可以简化为  gcc -Wall calc.c -lm -o cal.c
但是，时间发现我们即使不适用-lm也能正常编译，这是因为gcc默认帮我们做了处理

