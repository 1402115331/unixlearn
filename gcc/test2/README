-c是用来编译动态库的，并且对被编译的库的内容没有任何格式或形式上的要求，只要能最终连接就行啦   
另外这里的-c 不同于编译执行文件，-c编译的默认库的名字就是源代码的名字。这是因为不同于编译执行文件  
执行文件存在多个源代码编译到一个可执行文件的情况，但是编译动态库不存在这个问题...
编译动态库使用默认的文件名，不表示-o不能使用啦，仍然可以手动指定outputfile 类型

这里同样不需要对头文件做任何处理，并且我们发现头文件是不需要编译成二进制的，也就是说这些仍然保持文本的格式，只要保证在连接的时候做一个检查就行啦，这说明什么哪----这里一定有个重要信息
对于编译好的动态库直接使用gcc main.o hello_fn.o -o newhello编译就可以，这个和编译多个源文件的方法是一样的，区别是这里不需要加-Wall标志，因为main.o等动态库都是已经检测好的源文件才能被成功编译为动态库
注意在原来的动态库连接的时候不是扫描全景的动态库来查找合适的方法，而是从做都右查找，这样如果使用的A方法的B在A的左边就会出错----不过测试发现现代的编译器并不存在这样的问题   eg. gcc main.o hello_fn.o -o new1 可能会出错

头文件只是当需要编译的时候给编译器检查使用的，程序真正运行过程中是不使用头文件的，所以windows和mac下的头文件才会在编译器的安装目录下，就是因为这是给编译器使用的，头文件也正是在编译的时候使用一次。。。而在运行时候，对应的方法都已经成功的编译到的可执行文件中啦，所以只需要从可执行文件的方法去索引位置搜索就可以啦，也说明可执行文件的方法区只是通过方法名和头文件的方法名对应的，但是在二进制的情况下虽然能够区分数据的字节长度，但是数据的数据类型确实丢失的，头文件的作用就是用来区分二进制的指定字节个数究竟表示的是什么类选。必然在32位平台上int 和long都是4个字节，所以在二进制里是不能区分具体的类型的。。。
